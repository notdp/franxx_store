-- NOTE: Archived, read-only export.
-- This file is a flattened snapshot intended for SQL editors that
-- do not support psql include directives. Do not edit here.
-- Single source of truth lives under: supabase/schema/*.sql
-- 请勿直接修改本文件；唯一真源为 supabase/schema 目录下的分模块 SQL。
SET client_min_messages TO WARNING;
SET search_path TO public;

-- >>> BEGIN: supabase/schema/01_extensions.sql
-- Extensions
create extension if not exists "uuid-ossp";
create extension if not exists pgcrypto; -- for gen_random_uuid()

-- <<< END: supabase/schema/01_extensions.sql


-- >>> BEGIN: supabase/schema/02_types.sql
-- Role enum
do $$ begin
  create type public.app_role as enum ('user','admin','super_admin');
exception when duplicate_object then null; end $$;

-- Generic enums for new design
do $$ begin
  create type public.ai_platform as enum ('openai','anthropic');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.product_tag as enum ('chatgpt','claude','codex','claude_code');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.currency_code as enum ('USD','CNY','NGN');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.product_status as enum ('on_sale','sold_out','discontinued');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.order_type as enum ('new','renewal');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.order_payment_status as enum ('pending','paid','partially_refunded','refunded','canceled');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.order_delivery_status as enum ('pending','processing','delivered','failed');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.payment_status as enum ('pending','authorized','succeeded','failed','canceled','disputed','refunded','partially_refunded');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.card_brand as enum ('visa','mastercard','amex','discover','jcb','diners','unionpay','unknown');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.ios_account_status as enum ('active','locked','risk_control','suspended');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.slot_combo as enum ('none','openai_only','anthropic_only','both');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.email_status as enum ('available','allocated','reserved','recycled');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.virtual_card_status as enum ('active','frozen','expired','cancelled');
exception when duplicate_object then null; end $$;

do $$ begin
  create type public.discount_type as enum ('membership','code','squad','none');
exception when duplicate_object then null; end $$;
-- <<< END: supabase/schema/02_types.sql


-- >>> BEGIN: supabase/schema/models/users.sql
-- Users profile table extending auth.users
drop table if exists public.users cascade;
create table public.users (
  id              uuid primary key references auth.users(id) on delete cascade,
  email           text not null,
  name            text,
  avatar_url      text,
  provider        text check (provider in ('google','github')),
  stripe_customer_id text unique,
  created_at      timestamptz not null default timezone('utc'::text, now()),
  updated_at      timestamptz not null default timezone('utc'::text, now())
);

create index if not exists idx_users_email on public.users(email);
create index if not exists idx_users_stripe_customer_id on public.users(stripe_customer_id);

-- <<< END: supabase/schema/models/users.sql


-- >>> BEGIN: supabase/schema/models/user_roles.sql
-- User roles mapping using enum app_role
drop table if exists public.user_roles cascade;
create table public.user_roles (
  id          bigint generated by default as identity primary key,
  user_id     uuid not null references auth.users(id) on delete cascade,
  role        public.app_role not null default 'user',
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  unique(user_id)
);

-- <<< END: supabase/schema/models/user_roles.sql


-- >>> BEGIN: supabase/schema/models/packages.sql
-- Subscription packages
drop table if exists public.packages cascade;
create table public.packages (
  id              uuid primary key default gen_random_uuid(),
  name            text not null,
  original_price  numeric(10,2) not null,
  sale_price      numeric(10,2) not null,
  description     text,
  features        jsonb default '[]'::jsonb,
  popular         boolean default false,
  tier            text check (tier in ('standard','advanced','legendary')),
  stock           integer default 0,
  created_at      timestamptz not null default timezone('utc'::text, now()),
  updated_at      timestamptz not null default timezone('utc'::text, now()),
  deleted_at      timestamptz
);

create unique index if not exists uq_packages_name_active on public.packages(lower(name)) where deleted_at is null;
create index if not exists idx_packages_created_at on public.packages(created_at desc);

-- <<< END: supabase/schema/models/packages.sql


-- >>> BEGIN: supabase/schema/models/orders.sql
-- Recreate with extended fields (keep legacy columns for compatibility)
drop table if exists public.orders cascade;
create table public.orders (
  id                        uuid primary key default gen_random_uuid(),
  user_id                   uuid references public.users(id) on delete set null,
  package_id                uuid references public.packages(id) on delete set null,
  package_name              text,
  -- New product linkage (optional during transition)
  product_id                uuid,
  subscription_id           uuid,
  type                      public.order_type default 'new',

  -- Contact and legacy fields (kept for existing UI/API)
  phone                     text,
  email                     text,

  -- Delivery lifecycle (UI uses this today)
  status                    public.order_delivery_status not null default 'pending',

  -- Pricing
  amount                    numeric(10,2) not null,                   -- list price
  final_amount              numeric(10,2),                            -- after discount
  discount_type             public.discount_type default 'none',
  discount_snapshot         jsonb default '{}'::jsonb,
  currency                  public.currency_code not null default 'USD',

  -- Legacy payment hints on orders (Stripe detailed rows live in payments)
  payment_method            text default 'card',
  stripe_session_id         text unique,
  stripe_payment_intent_id  text,
  stripe_customer_id        text,
  payment_status            public.order_payment_status default 'pending',

  -- Optional delivery payload
  account                   jsonb,

  created_at                timestamptz not null default timezone('utc'::text, now()),
  updated_at                timestamptz not null default timezone('utc'::text, now()),
  paid_at                   timestamptz,
  delivered_at              timestamptz
);

create index if not exists idx_orders_user_id on public.orders(user_id);
create index if not exists idx_orders_status on public.orders(status);
create index if not exists idx_orders_created_at on public.orders(created_at desc);
create index if not exists idx_orders_email on public.orders(email);
create index if not exists idx_orders_stripe_session_id on public.orders(stripe_session_id);
create index if not exists idx_orders_stripe_payment_intent_id on public.orders(stripe_payment_intent_id);
create index if not exists idx_orders_payment_status on public.orders(payment_status);
-- <<< END: supabase/schema/models/orders.sql


-- >>> BEGIN: supabase/schema/models/payment_logs.sql
-- Stripe webhook event logs (service role access only; no RLS policies)
drop table if exists public.payment_logs cascade;
create table public.payment_logs (
  id              uuid primary key default gen_random_uuid(),
  stripe_event_id text unique not null,
  event_type      text not null,
  payload         jsonb not null,
  created_at      timestamptz not null default now(),
  processed_at    timestamptz
);

create index if not exists idx_payment_logs_stripe_event_id on public.payment_logs(stripe_event_id);
create index if not exists idx_payment_logs_event_type on public.payment_logs(event_type);
create index if not exists idx_payment_logs_created_at on public.payment_logs(created_at desc);

-- <<< END: supabase/schema/models/payment_logs.sql


-- >>> BEGIN: supabase/schema/models/products.sql
-- Products (catalog items) per docs design
drop table if exists public.products cascade;
create table public.products (
  id                 uuid primary key default gen_random_uuid(),
  name               text not null,
  platform           public.ai_platform not null,
  tag                public.product_tag not null,
  ios_ngn_price      numeric(10,2),
  ios_usd_price      numeric(10,2),
  web_usd_price      numeric(10,2),
  selling_price      numeric(10,2) not null,
  stock_quantity     integer default 0,
  reserved_quantity  integer default 0,
  sold_quantity      integer default 0,
  status             public.product_status not null default 'on_sale',
  description        text,
  created_at         timestamptz not null default timezone('utc'::text, now()),
  updated_at         timestamptz not null default timezone('utc'::text, now())
);

create index if not exists idx_products_status on public.products(status);
create index if not exists idx_products_platform_tag on public.products(platform, tag);
create index if not exists idx_products_created_at on public.products(created_at desc);

-- <<< END: supabase/schema/models/products.sql


-- >>> BEGIN: supabase/schema/models/virtual_cards.sql
-- Virtual cards (sensitive fields encrypted; admin-only access via RLS)
drop table if exists public.virtual_cards cascade;
create table public.virtual_cards (
  id                   uuid primary key default gen_random_uuid(),
  pan_encrypted        text unique, -- encrypted PAN (full card number)
  last4                text check (char_length(last4) = 4),
  brand                public.card_brand not null default 'unknown',
  expiry_date          date,
  cvv_encrypted        text,
  provider             text,
  holder_name          text,
  balance              numeric(12,2) default 0,
  currency             public.currency_code not null default 'NGN',
  status               public.virtual_card_status not null default 'active',
  billing_address_id   uuid,
  monthly_limit        numeric(12,2),
  used_this_month      numeric(12,2) default 0,
  notes                text,
  created_at           timestamptz not null default timezone('utc'::text, now()),
  updated_at           timestamptz not null default timezone('utc'::text, now())
);

create index if not exists idx_virtual_cards_status on public.virtual_cards(status);
create index if not exists idx_virtual_cards_provider on public.virtual_cards(provider);

-- <<< END: supabase/schema/models/virtual_cards.sql


-- >>> BEGIN: supabase/schema/models/ios_accounts.sql
-- iOS accounts bound to virtual cards; slot occupancy summarized in slot_combo
drop table if exists public.ios_accounts cascade;
create table public.ios_accounts (
  id                   uuid primary key default gen_random_uuid(),
  apple_id             text unique not null,
  password_encrypted   text not null,
  region               text, -- e.g., NG/US/GB/JP
  phone_number         text,
  virtual_card_id      uuid references public.virtual_cards(id) on delete set null,
  status               public.ios_account_status not null default 'active',
  slot_combo           public.slot_combo not null default 'none',
  risk_control_until   timestamptz,
  device_info          jsonb default '{}'::jsonb,
  last_login_at        timestamptz,
  total_spent          numeric(12,2) default 0,
  notes                text,
  created_at           timestamptz not null default timezone('utc'::text, now()),
  updated_at           timestamptz not null default timezone('utc'::text, now()),
  check (case when status <> 'active' then slot_combo = 'none' else true end)
);

create index if not exists idx_ios_accounts_status on public.ios_accounts(status);
create index if not exists idx_ios_accounts_region on public.ios_accounts(region);

-- <<< END: supabase/schema/models/ios_accounts.sql


-- >>> BEGIN: supabase/schema/models/email_accounts.sql
-- Email accounts used as service identities
drop table if exists public.email_accounts cascade;
create table public.email_accounts (
  id                 uuid primary key default gen_random_uuid(),
  email              text unique not null,
  password_encrypted text,
  phone_number       text,
  recovery_email     text,
  status             public.email_status not null default 'available',
  current_user_id    uuid references public.users(id) on delete set null,
  allocated_at       timestamptz,
  reserved_until     timestamptz,
  notes              text,
  created_at         timestamptz not null default timezone('utc'::text, now()),
  updated_at         timestamptz not null default timezone('utc'::text, now())
);

create index if not exists idx_email_accounts_status on public.email_accounts(status);
create index if not exists idx_email_accounts_user on public.email_accounts(current_user_id);

-- <<< END: supabase/schema/models/email_accounts.sql


-- >>> BEGIN: supabase/schema/models/email_platform_status.sql
-- Status of email accounts on specific AI platforms
drop table if exists public.email_platform_status cascade;
create table public.email_platform_status (
  id                 uuid primary key default gen_random_uuid(),
  email_account_id   uuid not null references public.email_accounts(id) on delete cascade,
  platform           public.ai_platform not null,
  status             text not null default 'active', -- active/banned/suspended
  banned_at          timestamptz,
  ban_reason         text,
  registered_at      timestamptz,
  last_active_at     timestamptz,
  created_at         timestamptz not null default timezone('utc'::text, now()),
  updated_at         timestamptz not null default timezone('utc'::text, now()),
  unique(email_account_id, platform)
);

create index if not exists idx_email_platform_status_platform on public.email_platform_status(platform);

-- <<< END: supabase/schema/models/email_platform_status.sql


-- >>> BEGIN: supabase/schema/models/payments.sql
-- Stripe payments log (charges and refunds) linked to orders
drop table if exists public.payments cascade;
create table public.payments (
  id                        uuid primary key default gen_random_uuid(),
  order_id                  uuid not null references public.orders(id) on delete cascade,
  provider                  text not null default 'stripe',
  kind                      text not null check (kind in ('charge','refund')),
  amount                    numeric(10,2) not null,
  currency                  public.currency_code not null default 'USD',
  status                    public.payment_status not null default 'pending',
  stripe_session_id         text,
  stripe_payment_intent_id  text,
  stripe_charge_id          text,
  stripe_refund_id          text,
  stripe_customer_id        text,
  stripe_event_id           text,
  error_message             text,
  occurred_at               timestamptz,
  created_at                timestamptz not null default timezone('utc'::text, now()),
  updated_at                timestamptz not null default timezone('utc'::text, now())
);

create unique index if not exists uq_payments_event on public.payments(stripe_event_id) where stripe_event_id is not null;
create unique index if not exists uq_payments_charge on public.payments(stripe_charge_id) where stripe_charge_id is not null and kind = 'charge';
create unique index if not exists uq_payments_refund on public.payments(stripe_refund_id) where stripe_refund_id is not null and kind = 'refund';
create index if not exists idx_payments_order on public.payments(order_id, created_at desc);

-- <<< END: supabase/schema/models/payments.sql


-- >>> BEGIN: supabase/schema/03_functions.sql
-- Generic updated_at trigger
create or replace function public.update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = timezone('utc'::text, now());
  return new;
end; $$ language plpgsql;

-- Attach updated_at triggers
drop trigger if exists trg_users_updated_at on public.users;
create trigger trg_users_updated_at
before update on public.users
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_packages_updated_at on public.packages;
create trigger trg_packages_updated_at
before update on public.packages
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_orders_updated_at on public.orders;
create trigger trg_orders_updated_at
before update on public.orders
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_user_roles_updated_at on public.user_roles;
create trigger trg_user_roles_updated_at
before update on public.user_roles
for each row execute function public.update_updated_at_column();

-- New tables (current design)
drop trigger if exists trg_products_updated_at on public.products;
create trigger trg_products_updated_at
before update on public.products
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_virtual_cards_updated_at on public.virtual_cards;
create trigger trg_virtual_cards_updated_at
before update on public.virtual_cards
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_ios_accounts_updated_at on public.ios_accounts;
create trigger trg_ios_accounts_updated_at
before update on public.ios_accounts
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_email_accounts_updated_at on public.email_accounts;
create trigger trg_email_accounts_updated_at
before update on public.email_accounts
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_email_platform_status_updated_at on public.email_platform_status;
create trigger trg_email_platform_status_updated_at
before update on public.email_platform_status
for each row execute function public.update_updated_at_column();

drop trigger if exists trg_payments_updated_at on public.payments;
create trigger trg_payments_updated_at
before update on public.payments
for each row execute function public.update_updated_at_column();

-- Insert profile on auth.users signup
create or replace function public.handle_new_user_profile()
returns trigger as $$
begin
  insert into public.users (id, email, name, avatar_url, provider)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', split_part(new.email, '@', 1)),
    new.raw_user_meta_data->>'avatar_url',
    new.raw_app_meta_data->>'provider'
  )
  on conflict (id) do nothing;
  return new;
end; $$ language plpgsql security definer;

drop trigger if exists trg_on_auth_user_created_profile on auth.users;
create trigger trg_on_auth_user_created_profile
  after insert on auth.users
  for each row execute function public.handle_new_user_profile();

-- Auto-create role on signup (first admin binding by email)
create or replace function public.handle_new_user_role()
returns trigger as $$
begin
  insert into public.user_roles (user_id, role)
  values (
    new.id,
    case when new.email = 'dp0x7ce@gmail.com' then 'super_admin'::public.app_role else 'user'::public.app_role end
  )
  on conflict (user_id) do nothing;
  return new;
end; $$ language plpgsql security definer;

drop trigger if exists trg_on_auth_user_created_role on auth.users;
create trigger trg_on_auth_user_created_role
  after insert on auth.users
  for each row execute function public.handle_new_user_role();

-- Role helpers
create or replace function public.is_super_admin(check_user_id uuid)
returns boolean as $$
begin
  return exists (
    select 1 from public.user_roles ur
    where ur.user_id = check_user_id and ur.role = 'super_admin'
  );
end; $$ language plpgsql security definer;

create or replace function public.is_admin(check_user_id uuid)
returns boolean as $$
begin
  return exists (
    select 1 from public.user_roles ur
    where ur.user_id = check_user_id and ur.role in ('admin','super_admin')
  );
end; $$ language plpgsql security definer;
-- <<< END: supabase/schema/03_functions.sql


-- >>> BEGIN: supabase/schema/04_rls.sql
-- Enable RLS
alter table public.users enable row level security;
alter table public.packages enable row level security;
alter table public.orders enable row level security;
alter table public.user_roles enable row level security;
alter table public.payment_logs enable row level security;
alter table public.products enable row level security;
alter table public.virtual_cards enable row level security;
alter table public.ios_accounts enable row level security;
alter table public.email_accounts enable row level security;
alter table public.email_platform_status enable row level security;
alter table public.payments enable row level security;

-- Ensure no permissive legacy policy remains
drop policy if exists "Service role can manage payment_logs" on public.payment_logs;

-- Users policies
drop policy if exists "Users can view own profile" on public.users;
create policy "Users can view own profile" on public.users
  for select using (auth.uid() = id);

drop policy if exists "Users can update own profile" on public.users;
create policy "Users can update own profile" on public.users
  for update using (auth.uid() = id);

drop policy if exists "Admins can view all users" on public.users;
create policy "Admins can view all users" on public.users
  for select using (public.is_admin(auth.uid()));

-- Packages policies
drop policy if exists "Packages are viewable by everyone" on public.packages;
create policy "Packages are viewable by everyone" on public.packages
  for select using (true);

drop policy if exists "Only admins can insert packages" on public.packages;
create policy "Only admins can insert packages" on public.packages
  for insert with check (public.is_admin(auth.uid()));

drop policy if exists "Only admins can update packages" on public.packages;
create policy "Only admins can update packages" on public.packages
  for update using (public.is_admin(auth.uid()));

drop policy if exists "Only admins can delete packages" on public.packages;
create policy "Only admins can delete packages" on public.packages
  for delete using (public.is_admin(auth.uid()));

-- Orders policies
drop policy if exists "Users can view own orders" on public.orders;
create policy "Users can view own orders" on public.orders
  for select using (auth.uid() = user_id or auth.email() = email);

drop policy if exists "Users can create own orders" on public.orders;
create policy "Users can create own orders" on public.orders
  for insert with check (auth.uid() = user_id or auth.email() = email);

drop policy if exists "Users can update own pending orders" on public.orders;
create policy "Users can update own pending orders" on public.orders
  for update using (auth.uid() = user_id and status in ('pending','processing'));

drop policy if exists "Admins can view all orders" on public.orders;
create policy "Admins can view all orders" on public.orders
  for select using (public.is_admin(auth.uid()));

drop policy if exists "Admins can update orders" on public.orders;
create policy "Admins can update orders" on public.orders
  for update using (public.is_admin(auth.uid()));

-- User roles policies
drop policy if exists "Users can view own role" on public.user_roles;
create policy "Users can view own role" on public.user_roles
  for select using (auth.uid() = user_id);

drop policy if exists "Super admin can view all roles" on public.user_roles;
create policy "Super admin can view all roles" on public.user_roles
  for select using (public.is_super_admin(auth.uid()));

drop policy if exists "Super admin can update roles" on public.user_roles;
create policy "Super admin can update roles" on public.user_roles
  for update using (public.is_super_admin(auth.uid()));

drop policy if exists "Super admin can insert roles" on public.user_roles;
create policy "Super admin can insert roles" on public.user_roles
  for insert with check (public.is_super_admin(auth.uid()));

-- Payment logs: no policies added (service role bypasses RLS). Leaving without policies prevents any non-service access.

-- Products policies
drop policy if exists "Products are viewable by everyone" on public.products;
create policy "Products are viewable by everyone" on public.products
  for select using (status = 'on_sale');

drop policy if exists "Only admins can write products" on public.products;
create policy "Only admins can write products" on public.products
  for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

-- Sensitive resource tables: admin only
drop policy if exists "Admins manage virtual_cards" on public.virtual_cards;
create policy "Admins manage virtual_cards" on public.virtual_cards
  for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

drop policy if exists "Admins manage ios_accounts" on public.ios_accounts;
create policy "Admins manage ios_accounts" on public.ios_accounts
  for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

drop policy if exists "Admins manage email_accounts" on public.email_accounts;
create policy "Admins manage email_accounts" on public.email_accounts
  for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

drop policy if exists "Admins manage email_platform_status" on public.email_platform_status;
create policy "Admins manage email_platform_status" on public.email_platform_status
  for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

-- Payments: users can view their own via orders; admins manage
drop policy if exists "Users can view own payments" on public.payments;
create policy "Users can view own payments" on public.payments
  for select using (
    exists (
      select 1 from public.orders o where o.id = order_id and (o.user_id = auth.uid() or o.email = auth.email())
    )
  );

drop policy if exists "Admins can manage payments" on public.payments;
create policy "Admins can manage payments" on public.payments
  for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

-- Grants (basic)
grant usage on schema public to anon, authenticated;
grant select, insert, update on public.users to authenticated;
grant select on public.packages to anon;
grant select, insert, update, delete on public.packages to authenticated;
grant select, insert, update on public.orders to authenticated;
grant select on public.user_roles to authenticated;
grant select on public.products to anon;
grant select, insert, update, delete on public.products to authenticated;
grant usage, select on all sequences in schema public to authenticated;
-- <<< END: supabase/schema/04_rls.sql


-- >>> BEGIN: supabase/schema/05_views.sql
create or replace view public.active_packages as
select * from public.packages where deleted_at is null;

-- Public catalog: products (declared inventory only)
create or replace view public.products_public as
select
  p.id,
  p.name,
  p.platform,
  p.tag,
  p.ios_ngn_price,
  p.ios_usd_price,
  p.web_usd_price,
  p.selling_price,
  p.stock_quantity,
  p.reserved_quantity,
  p.sold_quantity,
  p.status,
  p.description,
  p.created_at
from public.products p
where p.status = 'on_sale';
-- <<< END: supabase/schema/05_views.sql
